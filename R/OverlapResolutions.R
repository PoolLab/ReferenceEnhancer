#' @title  OverlapResolutions
#'
#' @description Based on original genome annotation GTF file and a list of
#' overlapping genes, generates recommended actions for overlapping genes.
#' This is an optional step that can help with decision making during the manual
#' curation step.
#'
#' Gene overlaps can be resolved by one of several strategies including
#' (i) leaving overlapping gene annotations unchanged if their exons don’t directly overlap,
#' (ii) deleting offending readthrough transcripts from upstream genes,
#' (iii) deleting offending premature gene transcripts from downstream genes,
#' (iv) deleting pseudogenes and non-protein coding genes with poor support and
#' no read mapping that obscure well established protein coding genes or
#' (v) for extensively overlapping genes deleting one and renaming the other to
#' capture otherwise discarded reads. As well annotated genomes contain several
#' thousand same-strand overlapping genes and properly resolving gene overlaps
#' often requires manual inspection of the locus to determine best course of action,
#' prioritization of genes for manual curation is often desirable. To this end,
#' OverlapResolutions function classifies genes to prioritize for direct inspection.
#' The following algorithm is used to classify genes for appropriate curation:
#' 1.	If gene overlaps with multiple genes:
#'    a.	If gene’s exons overlap with another gene’s exons --> classify for “Manual inspection”
#'    b.	If gene’s exons do not overlap with any other genes’ exons --> classify as “Keep as is”
#'    c.	Assign recommended action for overlapping genes:
#'        i.	If nested gene does not overlap with any other gene  classify as “Keep as is”
#'        ii.	If nested gene overlaps with more than one gene  classify for “Manual inspection”
#'2.	If gene overlaps with only one other gene, test whether gene is non-protein
#'coding/pseudogene (“Gm” and “…Rik” gene models in mice; “AC…” and “AL…” gene models in humans)
#'    a.	If both overlapping genes are non-protein coding/pseudogenes --> classify for
#'    “Manual inspection”
#'    b.	If only one gene in the overlapping gene pair is non-protein coding/pseudogene,
#'    test if genes have overlapping exons:
#'        i.	In case no overlapping exons --> classify both genes as “Keep as is”
#'        ii.	In case exons overlap --> mark non-protein coding/pseudogene for
#'        deletion (“Delete”).
#'    c.	If both genes are well supported genes:
#'        i.	If their exons don’t overlap --> mark both genes as “Keep as is”
#'        ii.	If their exons do overlap, determine the number of opposing gene’s
#'        exonic overlap for each exon of each gene and find the exon with most
#'        overlaps for both upstream and downstream gene to determine appropriate
#'        course of action:
#'            1.	If downstream gene’s exon has more overlaps than its upstream
#'            counterpart, classify downstream gene as “Premature transcript deletion”
#'            and upstream gene as “Keep as is”
#'            2.	If upstream gene’s exon has more overlaps than its downstream
#'            counterpart, classify upstream gene as “Readthrough transcript deletion”
#'            and downstream gene as “Keep as is”
#'            3.	Otherwise classify both for “Manual inspection”
#'The resulting recommendations can be used in the manual curation step, where
#'all genes that are not classified in the “Keep as is” category should directly
#'be scrutinized in the Ensembl genome browser (ensemble.org, with the correct
#'genome builds) and/or cross-referenced to the respective Refseq genome annotation
#'within the Integrated Genome Browser (IGV 2.11.9).
#'
#' @param genome_annotation Unoptimized genome annotation (e.g. Ensembl/10x Genomics)
#' default genome annotation GTF file. This should be a dataframe created with the
#' LoadGtf() function in this package.
#' @param overlap_data A list of overlapping genes generated by IdentifyOverlappers.
#' @param gene_pattern The pattern in gene names that is unique for pseudo- or
#' other low quality or low interest genes. Patterns for recognizing candidate
#' pseudo- or low quality genes can be defined with regular expressions for matching
#' gene names with a given pattern. See vignette (regular-expressions) in the stringr
#' package for details or examples below.
#'
#' @return Generates “overlapping_gene_list.csv” with added recommendations for
#' resolving gene overlaps in the “automatic_classification” column.
#' @export
#'
#' @examples
#' genome_annotation <- LoadGtf(unoptimized_annotation_path = "test_genes.gtf")
#' gene_overlaps <- IdentifyOverlappers(genome_annotation = genome_annotation)
#' OverlapResolutions(genome_annotation = genome_annotation, overlap_data = gene_overlaps, gene_pattern = c("^Gm", "Rik$"))
#'
#' # Note: The example treats genes starting with “Gm…” and ending with “…Rik” as
#' # pseudogenes. Additional patterns for recognizing candidate pseudo- or low-quality
#' # genes can be defined with regular expressions for matching gene names
#' # with a given pattern. See vignette(regular-expressions) in the stringr package
#' # for details.
OverlapResolutions <- function(genome_annotation, overlap_data, gene_pattern){
  gene_list <- unique(overlap_data$gene)
  gene_address <- rep(0, length(gene_list))
  for (i in 1:length(gene_list)){
    gene_address[i] <- which(overlap_data$gene==gene_list[i])[1]
  }

  overlap_data <- overlap_data[gene_address,]

  rownames(overlap_data) <- overlap_data[,'gene']

  overlap_data['automatic_classification'] <- NA

  for(key in (rownames(overlap_data))){

    # Check that the gene is not classified already
    if(is.na(overlap_data[key,'automatic_classification'])){
      gene_A <- subset(genome_annotation, gene_name == key)

      if(overlap_data[key,'number_of_gene_overlaps'] > 1){
        overlaps <- as.list(strsplit(overlap_data[key,'overlapping_genes'], ", "))

        for(item in overlaps[[1]]){
          gene_B = genome_annotation[genome_annotation['gene_name'] == item,]

          gene_A_exons = return_exons(gene_A)
          gene_B_exons = return_exons(gene_B)

          if(exon_overlap(gene_A_exons, gene_B_exons) == TRUE){

            overlap_data[item, 'automatic_classification'] = 'Manual inspection'

            if(is.na(overlap_data[key,'automatic_classification']) | overlap_data[key,'automatic_classification'] != 'Manual inspection'){
              overlap_data[key,'automatic_classification'] = 'Manual inspection'
            }
          }
          else{

            if(is.na(overlap_data[key,'automatic_classification'])){
              overlap_data[key,'automatic_classification'] = 'Keep as is'

              if(overlap_data[item,'number_of_gene_overlaps'] > 1){
                overlap_data[item,'automatic_classification'] = 'Manual inspection'
              }
              else{
                overlap_data[item,'automatic_classification'] = 'Keep as is'
              }
            }
          }
        }
      }

      if(overlap_data[key,'number_of_gene_overlaps'] == 1){
        overlapping <- overlap_data[key,'overlapping_genes'][[1]]
        gene_B <- subset(genome_annotation, gene_name == overlapping)
        strand <- gene_A[1,'strand']

        gene_A_exons = return_exons(gene_A)
        gene_B_exons = return_exons(gene_B)

        # Check if both - key and overlapping gene - are pseudogenes
        if(both_pseudo(key, overlapping, gene_pattern) == TRUE){
          overlap_data[key, 'automatic_classification'] = 'Manual inspection'
          overlap_data[overlapping[[1]], 'automatic_classification'] = 'Manual inspection'
        }

        # Check for pseudogene
        else if(pseudo_overlap(key, overlapping, gene_A_exons, gene_B_exons, gene_pattern) == key){
          overlap_data[key, 'automatic_classification'] = 'Delete'
          overlap_data[overlapping[[1]], 'automatic_classification'] = 'Keep as is'
        }

        else if(pseudo_overlap(key, overlapping, gene_A_exons, gene_B_exons, gene_pattern) == overlapping){
          overlap_data[key, 'automatic_classification'] = 'Keep as is'
          overlap_data[overlapping[[1]], 'automatic_classification'] = 'Delete'
        }

        else if(pseudo_overlap(key, overlapping, gene_A_exons, gene_B_exons, gene_pattern) == 'exonic'){
          overlap_data[key, 'automatic_classification'] = 'Keep as is'
          overlap_data[overlapping[[1]], 'automatic_classification'] = 'Keep as is'
        }

        # Check for readthrough
        else if(exon_overlap(gene_A_exons, gene_B_exons) == TRUE){
          if(strand == '+'){
            name_A = key
            name_B = overlapping
            result = readthrough_or_premature_plus(name_A, gene_A, name_B, gene_B, gene_A_exons, gene_B_exons)

            if(result[[3]] == 'readthrough'){
              overlap_data[result[[1]],'automatic_classification'] = 'Readthrough transcript deletion'
              overlap_data[result[[2]],'automatic_classification'] = 'Keep as is'
            }
            else if(result[[3]] == 'premature'){
              overlap_data[result[[1]],'automatic_classification'] = 'Keep as is'
              overlap_data[result[[2]],'automatic_classification'] = 'Premature transcript deletion'
            }
            else if(result[[3]] == 'manual'){
              overlap_data[result[[1]],'automatic_classification'] = 'Manual inspection'
              overlap_data[result[[2]],'automatic_classification'] = 'Manual inspection'
            }
          }

          else if(strand == '-'){
            name_A = key
            name_B = overlapping
            result = readthrough_or_premature_min(name_A, gene_A, name_B, gene_B, gene_A_exons, gene_B_exons)

            if(result[[3]] == 'readthrough'){
              overlap_data[result[[1]],'automatic_classification'] = 'Readthrough transcript deletion'
              overlap_data[result[[2]],'automatic_classification'] = 'Keep as is'
            }
            else if(result[[3]] == 'premature'){
              overlap_data[result[[1]],'automatic_classification'] = 'Keep as is'
              overlap_data[result[[2]],'automatic_classification'] = 'Premature transcript deletion'
            }
            else if(result[[3]] == 'manual'){
              overlap_data[result[[1]],'automatic_classification'] = 'Manual inspection'
              overlap_data[result[[2]],'automatic_classification'] = 'Manual inspection'
            }
          }
        }

        else if(exon_overlap(gene_A_exons, gene_B_exons) == FALSE){
          overlap_data[key,'automatic_classification'] = 'Keep as is'
          overlap_data[overlapping,'automatic_classification'] = 'Keep as is'
        }
      }
    }
  }

  print("Overlapping genes list (overlapping_gene_list.csv) has been updated with recommended action categories and the file has been saved in your working directory")
  write_csv(overlap_data, "overlapping_gene_list.csv")

}
